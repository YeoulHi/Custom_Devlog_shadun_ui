---
description: 
globs: 
alwaysApply: false
---
# 점진적 리팩토링 프로세스

## 🔄 점진적 리팩토링의 필요성

### 리팩토링의 위험성
- **코드 변경의 위험**: 작동하는 코드를 수정하는 것은 "달리는 자동차의 바퀴를 바꾸는 것"과 같은 위험이 있음
- **예기치 않은 버그**: 대규모 리팩토링은 예상치 못한 버그와 회귀 오류를 발생시킬 수 있음
- **일정 지연**: 큰 변경사항은 코드 리뷰와 테스트에 많은 시간이 소요됨

### 점진적 접근의 이점
- **위험 최소화**: 작은 단위의 변경으로 문제 발생 시 원인 파악이 용이
- **지속적 배포**: 작은 변경사항은 빠르게 리뷰되고 병합될 수 있음
- **병렬 작업 가능**: 다른 기능 개발과 동시에 리팩토링 진행 가능

## 📋 점진적 리팩토링 핵심 원칙

### 1. 작은 단위로 변경하기
- **한 번에 하나만 변경**: 하나의 리팩토링은 하나의 개념만 변경해야 함
- **1-2시간 내 완료**: 각 리팩토링 작업은 짧은 시간 내에 완료 가능해야 함
- **독립적인 변경**: 각 변경사항은 다른 변경사항에 의존하지 않고 독립적으로 병합 가능해야 함

### 2. 테스트 주도 리팩토링
- **변경 전 테스트 작성**: 리팩토링 전에 현재 동작을 검증하는 테스트 작성
- **변경 후 테스트 실행**: 모든 변경 후 테스트를 실행하여 기능이 그대로 유지되는지 확인
- **테스트 커버리지 유지**: 리팩토링 과정에서 테스트 커버리지가 감소하지 않도록 관리

### 3. 점진적 변경 패턴
- **병렬 구현 전략**: 기존 코드를 유지한 채 새로운 구현을 추가하고 점진적으로 전환
- **단계적 마이그레이션**: 기존 API와 새 API를 동시에 지원하며 점진적으로 마이그레이션
- **스트랭글러 패턴(Strangler Fig Pattern)**: 기존 시스템을 점진적으로 새 시스템으로 대체

### 4. 가치 중심 우선순위
- **실제 문제 우선**: 이론적인 개선보다 실제 문제를 해결하는 리팩토링 우선
- **Rule of Three**: 최소 3곳 이상에서 사용되는 패턴만 추상화
- **비용 대비 효과 고려**: 리팩토링에 투자하는 시간과 얻는 이점을 균형있게 고려

## 🛠️ 점진적 리팩토링 프로세스

### 1. 분석 및 계획 단계
- **문제점 식별 및 문서화**: 리팩토링이 필요한 영역과 이유를 명확히 정의
- **현재 상태 테스트 작성**: 현재 동작을 검증하는 테스트 작성
- **단계별 계획 수립**: 리팩토링을 작은 단계로 나누고 순서 결정

### 2. 단계별 리팩토링 실행
- **새 기능 추가**: 기존 기능을 유지하면서 새로운 구현 추가
- **점진적 전환**: 기존 코드를 새 구현으로 한 부분씩 전환
- **즉시 테스트**: 각 변경 후 즉시 테스트 실행

### 3. 완료 및 정리
- **기존 코드 제거**: 모든 사용처가 새 구현으로 전환된 후 기존 코드 제거
- **문서화**: 변경사항과 새로운 패턴 문서화
- **성과 측정**: 리팩토링 전후의 코드 품질, 성능 등 측정

## 📊 구체적인 리팩토링 패턴

### 1. 메서드 변경 패턴
```typescript
// 1단계: 새 메서드 추가 (오버로드 또는 새 이름)
class Lotto {
  match(lotto: number[]): number { /* 기존 구현 */ }
  matchLotto(lotto: Lotto): number { /* 새 구현 */ }
}

// 2단계: 기존 메서드에서 새 메서드 호출
class Lotto {
  match(lotto: number[]): number {
    return this.matchLotto(new Lotto(lotto));
  }
  matchLotto(lotto: Lotto): number { /* 새 구현 */ }
}

// 3단계: 모든 호출 지점 업데이트 후 기존 메서드 제거
class Lotto {
  matchLotto(lotto: Lotto): number { /* 새 구현 */ }
}
```

### 2. 데이터 구조 변경 패턴
```typescript
// 1단계: 새 필드 추가 및 동기화 유지
class User {
  name: string;
  fullName: string; // 새 필드
  
  setName(name: string) {
    this.name = name;
    this.fullName = name; // 동기화
  }
}

// 2단계: 모든 사용처를 새 필드로 전환

// 3단계: 기존 필드 제거
class User {
  fullName: string;
  
  setName(name: string) {
    this.fullName = name;
  }
}
```

### 3. 컴포넌트 추출 패턴
```tsx
// 1단계: 새 컴포넌트 생성 및 원본 컴포넌트에서 사용
function PostPage() {
  // 기존 구현...
  return (
    <div>
      <PostHeader title={post.title} author={post.author} /> {/* 추출된 컴포넌트 */}
      {/* 나머지 구현... */}
    </div>
  );
}

// 2단계: 추출된 컴포넌트로 로직 이동
function PostHeader({ title, author }) {
  // 헤더 관련 로직 이동
  return (
    <div className="post-header">
      <h1>{title}</h1>
      <p>By {author.name}</p>
    </div>
  );
}
```

## 🔍 측정 및 평가

### 리팩토링 성공 지표
- **코드 품질 지표**: 복잡도, 중복률, 응집도 등
- **성능 지표**: 로드 시간, 번들 크기, 메모리 사용량
- **개발자 생산성**: 기능 개발 속도, 버그 수정 시간

### 지속적 개선
- **리팩토링 회고**: 완료된 리팩토링의 효과와 프로세스 평가
- **패턴 문서화**: 효과적인 리팩토링 패턴 문서화
- **지식 공유**: 팀 내 리팩토링 경험과 학습 공유

## 📝 결론

점진적 리팩토링은 위험을 최소화하면서 코드 품질을 지속적으로 개선하는 효과적인 방법입니다. 작은 단위로 변경하고, 각 단계마다 테스트하며, 실제 문제에 집중하는 접근법은 안정적인 코드베이스를 유지하면서 기술 부채를 관리하는 데 도움이 됩니다. 이 문서에 제시된 원칙과 패턴을 따라 리팩토링을 진행한다면, 대규모 재작성 없이도 코드베이스를 점진적으로 개선할 수 있습니다.


**핵심 교훈**: "작게 변경하고, 자주 테스트하고, 점진적으로 개선하라"